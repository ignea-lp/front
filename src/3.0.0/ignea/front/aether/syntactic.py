# This file was automatically generated by Aether, the front-end
# generator for the Ignea language processing infrastructure.

# Ignea front-end, front-end libraries and utilities for the
# Ignea language processing infrastructure
# Copyright (C) 2024  Natan Junges <natanajunges@gmail.com>
# Copyright (C) 2024, 2025  The Ignea Project
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from ignea.front.syntactic import (
    ignea_selection,
    IgneaNonterminalType,
    IgneaParser,
    IgneaDerivationException,
)
from .common import Conditions
from .lexical import *


class Grammar(IgneaNonterminalType):
    @staticmethod
    def start(conditions):
        return True

    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.derive(Production, next_states[-1])
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                next_states[-1] = parser.derive(Production, next_states[-1])
            except IgneaDerivationException:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        return next_states[0]


class Production(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.derive(ProductionHeader, next_states[-1])
        next_states[-1] = parser.derive(ProductionBody, next_states[-1])
        return next_states[0]


class ProductionHeader(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.derive(Identifier, next_states[-1])

        if Conditions.lexical in parser.lexer.conditions:
            try:  # begin optional
                next_states.append(next_states[-1])
                next_states[-1] = parser.derive(Condition, next_states[-1])
            except IgneaDerivationException:
                next_states.pop()
            else:
                next_states[-1] = next_states.pop()  # end optional

        try:  # begin optional
            next_states.append(next_states[-1])
            next_states[-1] = parser.derive(
                ProductionSpecifiers, next_states[-1]
            )
        except IgneaDerivationException:
            next_states.pop()
        else:
            next_states[-1] = next_states.pop()  # end optional

        next_states[-1] = parser.derive(Colon, next_states[-1])
        return next_states[0]


class ProductionBody(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.derive(SelectionExpression, next_states[-1])
        next_states[-1] = parser.derive(Semicolon, next_states[-1])
        return next_states[0]


class Condition(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.derive(CommercialAt, next_states[-1])
        next_states[-1] = parser.derive(DisjunctionCondition, next_states[-1])
        return next_states[0]


class ProductionSpecifiers(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.derive(LeftParenthesis, next_states[-1])
        next_states[-1] = parser.derive(
            ProductionSpecifierList, next_states[-1]
        )
        next_states[-1] = parser.derive(RightParenthesis, next_states[-1])
        return next_states[0]


class SelectionExpression(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.derive(SequenceExpression, next_states[-1])
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                for _ in ignea_selection:  # begin selection
                    try:  # begin option
                        next_states.append(next_states[-1])
                        next_states[-1] = parser.derive(
                            VerticalLine, next_states[-1]
                        )
                    except IgneaDerivationException:
                        next_states.pop()
                    else:
                        break  # end option

                    if Conditions.syntactic in parser.lexer.conditions:
                        next_states.append(next_states[-1])  # begin option

                        try:
                            next_states[-1] = parser.derive(
                                Solidus, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                    raise IgneaDerivationException()

                next_states[-1] = next_states.pop()  # end selection
                next_states[-1] = parser.derive(
                    SequenceExpression, next_states[-1]
                )
            except IgneaDerivationException:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        return next_states[0]


class DisjunctionCondition(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.derive(ConjunctionCondition, next_states[-1])
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                next_states[-1] = parser.derive(
                    DoubleVerticalLine, next_states[-1]
                )
                next_states[-1] = parser.derive(
                    ConjunctionCondition, next_states[-1]
                )
            except IgneaDerivationException:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        return next_states[0]


class ProductionSpecifierList(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.derive(ProductionSpecifier, next_states[-1])
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                next_states[-1] = parser.derive(Comma, next_states[-1])
                next_states[-1] = parser.derive(
                    ProductionSpecifier, next_states[-1]
                )
            except IgneaDerivationException:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        return next_states[0]


class SequenceExpression(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in ignea_selection:  # begin selection
            if Conditions.lexical in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    next_states[-1] = parser.derive(
                        IterationExpression, next_states[-1]
                    )
                    next_states.append(next_states[-1])  # begin iteration

                    while True:
                        try:
                            next_states[-1] = parser.derive(
                                IterationExpression, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                            break

                        next_states[-2] = next_states[-1]  # end iteration
                except IgneaDerivationException:
                    next_states.pop()
                else:
                    break  # end option

            if Conditions.syntactic in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    next_states[-1] = parser.derive(
                        PrimaryExpression, next_states[-1]
                    )
                    next_states.append(next_states[-1])  # begin iteration

                    while True:
                        try:
                            next_states[-1] = parser.derive(
                                PrimaryExpression, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                            break

                        next_states[-2] = next_states[-1]  # end iteration
                except IgneaDerivationException:
                    next_states.pop()
                else:
                    break  # end option

            raise IgneaDerivationException()

        next_states[-1] = next_states.pop()  # end selection
        return next_states[0]


class ConjunctionCondition(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.derive(NegationCondition, next_states[-1])
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                next_states[-1] = parser.derive(
                    DoubleAmpersand, next_states[-1]
                )
                next_states[-1] = parser.derive(
                    NegationCondition, next_states[-1]
                )
            except IgneaDerivationException:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        return next_states[0]


class ProductionSpecifier(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in ignea_selection:  # begin selection
            if Conditions.lexical in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    for _ in ignea_selection:  # begin selection
                        try:  # begin option
                            next_states.append(next_states[-1])

                            for _ in ignea_selection:  # begin selection
                                try:  # begin option
                                    next_states.append(next_states[-1])
                                    next_states[-1] = parser.derive(
                                        PlusSign, next_states[-1]
                                    )
                                except IgneaDerivationException:
                                    next_states.pop()
                                else:
                                    break  # end option

                                try:  # begin option
                                    next_states.append(next_states[-1])
                                    next_states[-1] = parser.derive(
                                        HyphenMinus, next_states[-1]
                                    )
                                except IgneaDerivationException:
                                    next_states.pop()
                                else:
                                    break  # end option

                                raise IgneaDerivationException()

                            next_states[-1] = (
                                next_states.pop()
                            )  # end selection
                            next_states[-1] = parser.derive(
                                Identifier, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.derive(
                                Ignore, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                        raise IgneaDerivationException()

                    next_states[-1] = next_states.pop()  # end selection
                except IgneaDerivationException:
                    next_states.pop()
                else:
                    break  # end option

            if Conditions.syntactic in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    next_states[-1] = parser.derive(Start, next_states[-1])
                except IgneaDerivationException:
                    next_states.pop()
                else:
                    break  # end option

            raise IgneaDerivationException()

        next_states[-1] = next_states.pop()  # end selection

        try:  # begin optional
            next_states.append(next_states[-1])
            next_states[-1] = parser.derive(Condition, next_states[-1])
        except IgneaDerivationException:
            next_states.pop()
        else:
            next_states[-1] = next_states.pop()  # end optional

        return next_states[0]


class IterationExpression(IgneaNonterminalType):
    @staticmethod
    def first(conditions):
        first = set()

        if Conditions.lexical in conditions:
            first.add(PrimaryExpression)

        return first

    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in ignea_selection:  # begin selection
            if Conditions.lexical in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    next_states[-1] = parser.derive(
                        PrimaryExpression, next_states[-1], cls
                    )

                    try:  # begin optional
                        next_states.append(next_states[-1])

                        for _ in ignea_selection:  # begin selection
                            try:  # begin option
                                next_states.append(next_states[-1])
                                next_states[-1] = parser.derive(
                                    Asterisk, next_states[-1]
                                )
                            except IgneaDerivationException:
                                next_states.pop()
                            else:
                                break  # end option

                            try:  # begin option
                                next_states.append(next_states[-1])
                                next_states[-1] = parser.derive(
                                    PlusSign, next_states[-1]
                                )
                            except IgneaDerivationException:
                                next_states.pop()
                            else:
                                break  # end option

                            try:  # begin option
                                next_states.append(next_states[-1])
                                next_states[-1] = parser.derive(
                                    QuestionMark, next_states[-1]
                                )
                            except IgneaDerivationException:
                                next_states.pop()
                            else:
                                break  # end option

                            try:  # begin option
                                next_states.append(next_states[-1])
                                next_states[-1] = parser.derive(
                                    ExpressionRange, next_states[-1]
                                )
                            except IgneaDerivationException:
                                next_states.pop()
                            else:
                                break  # end option

                            raise IgneaDerivationException()

                        next_states[-1] = next_states.pop()  # end selection
                    except IgneaDerivationException:
                        next_states.pop()
                    else:
                        next_states[-1] = next_states.pop()  # end optional
                except IgneaDerivationException:
                    next_states.pop()
                else:
                    break  # end option

            if Conditions.syntactic in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    for _ in ignea_selection:  # begin selection
                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.derive(
                                LeftCurlyBracket, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.derive(
                                LeftCurlyBracketSolidus, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                        raise IgneaDerivationException()

                    next_states[-1] = next_states.pop()  # end selection
                    next_states[-1] = parser.derive(
                        SelectionExpression, next_states[-1]
                    )
                    next_states[-1] = parser.derive(
                        RightCurlyBracket, next_states[-1]
                    )
                except IgneaDerivationException:
                    next_states.pop()
                else:
                    break  # end option

            raise IgneaDerivationException()

        next_states[-1] = next_states.pop()  # end selection
        return next_states[0]


class PrimaryExpression(IgneaNonterminalType):
    @staticmethod
    def first(conditions):
        first = set()

        if Conditions.syntactic in conditions:
            first.add(IterationExpression)

        return first

    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in ignea_selection:  # begin selection
            if Conditions.lexical in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    for _ in ignea_selection:  # begin selection
                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.derive(
                                OrdChar, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.derive(
                                QuotedChar, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.derive(
                                FullStop, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.derive(
                                BracketExpression, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                        raise IgneaDerivationException()

                    next_states[-1] = next_states.pop()  # end selection
                except IgneaDerivationException:
                    next_states.pop()
                else:
                    break  # end option

            if Conditions.syntactic in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    next_states[-1] = parser.derive(
                        Identifier, next_states[-1]
                    )

                    try:  # begin optional
                        next_states.append(next_states[-1])
                        next_states[-1] = parser.derive(
                            Condition, next_states[-1]
                        )
                    except IgneaDerivationException:
                        next_states.pop()
                    else:
                        next_states[-1] = next_states.pop()  # end optional
                except IgneaDerivationException:
                    next_states.pop()
                else:
                    break  # end option

            try:  # begin option
                next_states.append(next_states[-1])
                next_states[-1] = parser.derive(
                    LeftParenthesis, next_states[-1]
                )
                next_states[-1] = parser.derive(
                    SelectionExpression, next_states[-1]
                )
                next_states[-1] = parser.derive(
                    RightParenthesis, next_states[-1]
                )

                if Conditions.syntactic in parser.lexer.conditions:
                    try:  # begin optional
                        next_states.append(next_states[-1])
                        next_states[-1] = parser.derive(
                            Condition, next_states[-1]
                        )
                    except IgneaDerivationException:
                        next_states.pop()
                    else:
                        next_states[-1] = next_states.pop()  # end optional
            except IgneaDerivationException:
                next_states.pop()
            else:
                break  # end option

            if Conditions.syntactic in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    for _ in ignea_selection:  # begin selection
                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.derive(
                                OptionalExpression, next_states[-1]
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.derive(
                                IterationExpression, next_states[-1], cls
                            )
                        except IgneaDerivationException:
                            next_states.pop()
                        else:
                            break  # end option

                        raise IgneaDerivationException()

                    next_states[-1] = next_states.pop()  # end selection

                    try:  # begin optional
                        next_states.append(next_states[-1])
                        next_states[-1] = parser.derive(
                            Condition, next_states[-1]
                        )
                    except IgneaDerivationException:
                        next_states.pop()
                    else:
                        next_states[-1] = next_states.pop()  # end optional
                except IgneaDerivationException:
                    next_states.pop()
                else:
                    break  # end option

            raise IgneaDerivationException()

        next_states[-1] = next_states.pop()  # end selection
        return next_states[0]


class NegationCondition(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                next_states[-1] = parser.derive(
                    ExclamationMark, next_states[-1]
                )
            except IgneaDerivationException:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        next_states[-1] = parser.derive(PrimaryCondition, next_states[-1])
        return next_states[0]


class OptionalExpression(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in ignea_selection:  # begin selection
            try:  # begin option
                next_states.append(next_states[-1])
                next_states[-1] = parser.derive(
                    LeftSquareBracket, next_states[-1]
                )
            except IgneaDerivationException:
                next_states.pop()
            else:
                break  # end option

            try:  # begin option
                next_states.append(next_states[-1])
                next_states[-1] = parser.derive(
                    LeftSquareBracketSolidus, next_states[-1]
                )
            except IgneaDerivationException:
                next_states.pop()
            else:
                break  # end option

            raise IgneaDerivationException()

        next_states[-1] = next_states.pop()  # end selection
        next_states[-1] = parser.derive(SelectionExpression, next_states[-1])
        next_states[-1] = parser.derive(RightSquareBracket, next_states[-1])
        return next_states[0]


class PrimaryCondition(IgneaNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in ignea_selection:  # begin selection
            try:  # begin option
                next_states.append(next_states[-1])
                next_states[-1] = parser.derive(Identifier, next_states[-1])
            except IgneaDerivationException:
                next_states.pop()
            else:
                break  # end option

            try:  # begin option
                next_states.append(next_states[-1])
                next_states[-1] = parser.derive(
                    LeftParenthesis, next_states[-1]
                )
                next_states[-1] = parser.derive(
                    DisjunctionCondition, next_states[-1]
                )
                next_states[-1] = parser.derive(
                    RightParenthesis, next_states[-1]
                )
            except IgneaDerivationException:
                next_states.pop()
            else:
                break  # end option

            raise IgneaDerivationException()

        next_states[-1] = next_states.pop()  # end selection
        return next_states[0]


class Parser(IgneaParser):
    NONTERMINAL_TYPES = [
        Grammar,
        Production,
        ProductionHeader,
        ProductionBody,
        Condition,
        ProductionSpecifiers,
        SelectionExpression,
        DisjunctionCondition,
        ProductionSpecifierList,
        SequenceExpression,
        ConjunctionCondition,
        ProductionSpecifier,
        IterationExpression,
        PrimaryExpression,
        NegationCondition,
        OptionalExpression,
        PrimaryCondition,
    ]
